Reentrant OCaml
===============

This branch is the first step towards multicore support in OCaml. The
reentrant runtime will allow multiple runtimes to run independantly in
the same process. It can be used either to run these runtimes in
different threads, or when multiple OCaml runtimes are exposed as C
libraries.

Status
------

### DONE

* Most static variables of the runtime have been moved into the context
* Most C functions of the runtime have been renamed to _r(CAML_R, to take
  as first parameter the runtime context containing all former static variables.
* External functions in OCaml can now be declared as "reentrant", i.e. receiving
  the context as first parameter.
* The AMD64 backend of ocamlopt has been updated to use the runtime context and
  provide it to reentrant external functions.
* C functions in unix, str, bigarray have been updated, static variables have been moved
  into library specific contexts.

### TODO

* Globals generated by ocamlopt are still shared
* Only the AMD64 backend has been implemented. Implement the other ones.
* Only TLS (Thread Local Storage) is currenty supported.
* At the end, we need to provide all the functions that were renamed in _r in
  their older format, for backward compatibility.
* Update C functions in otherlibs/

Principles
----------

Each function in the runtime takes as first argument a "runtime
context", containing all the variables that used to be static. To
decrease the size of the patch, the file context.h defines for each
variable a macro that lookup the variable within the context. All
these functions have a suffix _r, and the macro CAML_R defines their
first argument.

Once all functions will have been rewritten like that, we should
implement the former version (without the first argument) by looking
up the context in the thread local storage, using the function
"caml_get_global_context()".

Since we needed a global lock for all the runtimes, it has been
implemented as "caml_enter_blocking_section()" (which should still be
used for exclusion within a given runtime), by introducing two
functions "caml_enter_lock_section()" and
"caml_leave_lock_section()". These functions don't do anything right
now, but locking should be added within the thread libraries by
redefining "caml_enter_lock_section_hook" and
"caml_leave_lock_section_hook".

For static variables within libraries, the library should define its
own runtime context, and use "caml_get_library_context_r(...)" to
access it. Such contexts are currently limited to 24
(MAX_OTHER_CONTEXTS), but the limitation should be removed soon.

